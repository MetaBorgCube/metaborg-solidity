module analysis/solidity

imports

  signatures/-
  desugar/numbers
  
  analysis/types
  
  analysis/contracts
  analysis/enums
  analysis/events
  analysis/expressions
  analysis/functionmodifiers
  analysis/functions
  analysis/globals
  analysis/interfaces
  analysis/libraries
  analysis/modifiers
  analysis/modifiertypes
  analysis/pragmas
  analysis/solimports
  analysis/statements
  analysis/statevariables
  analysis/structs
  analysis/usingfor
  analysis/vars
  
  analysis/subtypes/addresses
  analysis/subtypes/bytearrays
  analysis/subtypes/integers
  analysis/subtypes/numberliterals
  analysis/subtypes/stringliterals
  analysis/subtypes/vars

signature
  name resolution
    labels
      // P = Parent (method -> class, class -> program)
      // I = Import (class -> super)
      // M = Method Parent (method -> class)
      // J = Method Import (class -> super)
      P I M J

    order
      // Check local declarations over imports and parents
      D < P,
      D < I,
      
      // Check imports before parents
      I < P,
      
      // J is used for method overriding
      J < D,
      J < I

    well-formedness
      // P* I*   gives: D < PD < PI+D       = Local (var/param) over parent (field/method/classname) over import (super field/super method)
      //                PPD                 = Class lookup (Method -> Class -> Program -> Class Definition)
      
      // M J? I* gives: MJD < MD            = Look in direct super before using local
      //                MJD < MIID          = We first check in the direct super class before looking further
      //                MJI{n}D < MJI{n+1}D = Prefer closer super methods, check all the way
      (P* I*) | (M J? I*)

  namespaces
    Referrable
  
  sorts
    NaBLBool
    TypeTest
  
  constructors
    NaBLFalse : NaBLBool
    NaBLTrue  : NaBLBool
    
    IsType            : TypeTest
    IsNumeric         : TypeTest
    CanCompare        : TypeTest
    CanCompareOrdered : TypeTest
    CanArithBasic     : TypeTest
    CanPow            : TypeTest
    CanBitwiseOps     : TypeTest
    CanIndex          : TypeTest
    
  relations
    reflexive, anti-symmetric, transitive sub  : Type * Type {
      [+sub],
      FArrayT(+sub),
      DArrayT(+sub),
      TupleT(+sub)
    }
    
    reflexive, anti-symmetric, transitive vissub : VisibilityType * VisibilityType {
      [+vissub]
    }
    
    anti-symmetric, anti-transitive test : Type * TypeTest
    
    reflexive cast : Type * Type
  
  functions
  
    /**
     * Returns NaBLFalse if the given term is zero.
     * Returns NaBLTrue otherwise (term is non-zero).
     */
    notZeroConst: Term -> NaBLBool {
      IntLiteral("0", _, _) -> NaBLFalse(),
      IntLiteral(i,   _, _) -> NaBLTrue(),
      exp                   -> NaBLTrue()
    }
    
    /**
     * Returns NaBLFalse if the given term is negative.
     * Returns NaBLTrue otherwise (term is positive).
     */
    notNegativeConst: Term -> NaBLBool {
      IntLiteral(i, _, None()) -> NaBLFalse(),
      IntLiteral(i, _, _)      -> NaBLTrue(),
      exp                      -> NaBLTrue()
    }
    
    /**
     * Throws away type specicality information, e.g. int8 -> int and bytes32 -> bytes.
     */
    simplifyType: Type -> Type {
      IntT(i)            -> IntTS(),
      UIntT(i)           -> UIntTS(),
      NrT(i, 0)          -> IntTS(),
      NrT(i, u)          -> UIntTS(), //Simplify NrT to UInt, as UInt can be used in more places
      FractT(_, _, _, _) -> UFixedTS(),
      FBytesT(i)         -> FBytesTS(),
      FixedT(m, n)       -> FixedTS(),
      UFixedT(m, n)      -> UFixedTS(),
      NamedT(o, st)      -> NamedTS(),
      
      FArrayT(_, _)      -> FArrayTS(),
      DArrayT(_)         -> DArrayTS(),
      other              -> other
    }
    
    /**
     * Determines the type of the elements in an array.
     */
    arrayType: Type -> Type {
      FBytesT(_)    -> NrT(8, 8),
      DBytesT()     -> NrT(8, 8),
      FArrayT(t, _) -> t,
      DArrayT(t)    -> t
    }
    
    /*
     * Convert type to an unsigned type, or returns the original type.
     */
    toUnsigned: Type -> Type {
      UIntT(i)           -> UIntT(i),      //Already an UInt
      NrT(i, 0)          -> NrT(i, 0),     //Not valid as UInt
      NrT(_, u)          -> UIntT(u),      //Valid as UInt
      FractT(_, _, m, n) -> UFixedT(m, n), //Valid as UFixed
      ty                 -> ty             //Invalid
    }
    
    /**
     * Converts type to a signed type, or returns the original type.
     */
    toSigned: Type -> Type {
      IntT(i)            -> IntT(i),
      NrT(i, _)          -> IntT(i),
      FractT(m, n, _, _) -> FixedT(m, n),
      ty                 -> ty
    }
    
//    //Increases the given number by 8
//    plus8: Term -> Term {
//      0   -> 0,  //0 stays 0 (invalid)
//      8   -> 16,
//      16  -> 24,
//      24  -> 32,
//      32  -> 40,
//      40  -> 48,
//      48  -> 56,
//      56  -> 64,
//      64  -> 72,
//      72  -> 80,
//      80  -> 88,
//      88  -> 96,
//      96  -> 104,
//      104 -> 112,
//      112 -> 120,
//      120 -> 128,
//      128 -> 136,
//      136 -> 144,
//      144 -> 152,
//      152 -> 160,
//      160 -> 168,
//      168 -> 176,
//      176 -> 184,
//      184 -> 192,
//      192 -> 200,
//      200 -> 208,
//      208 -> 216,
//      216 -> 224,
//      224 -> 232,
//      232 -> 240,
//      240 -> 248,
//      248 -> 256,
//      256 -> 0 //Becomes invalid number
//    }
//    
//    //Converts the type to the bound
//    tyToNr: Type -> Term {
//      IntT(x)       -> x,
//      UIntT(x)      -> x,
//      FixedT(m, n)  -> [m, n],
//      UFixedT(m, n) -> [m, n],
//      FBytesT(n)    -> n,
//      FArrayT(_, n) -> n,
//      _             -> NaBLFalse() //Invalid
//    }
//    
//    termToTy: (Term * Type) -> Type {
//      (x, IntTS())         -> IntT(x),
//      (x, UIntTS())        -> UIntT(x),
//      ([m, n], FixedTS())  -> FixedT(m, n),
//      ([m, n], UFixedTS()) -> UFixedT(m, n),
//      (x, FBytesTS())      -> FBytesT(x),
//      (x, FArrayTS(aty))   -> FArrayT(x, aty),
//      (_, _)               -> InvalidType()
//    }

rules

  init ^ (programScope) :=
    new programScope,
    
    //TODO Substringlit
    
    //Casting int -> int/uint ; uint -> int/uint
    IntTS()  <cast! IntTS(),
    UIntTS() <cast! IntTS(),
    IntTS()  <cast! UIntTS(),
    UIntTS() <cast! UIntTS(),
//    NrTS() <cast! IntTS(),
//    NrTS() <cast! UIntTS(),
    
    
    //Casting string -> bytes
    DBytesT() <cast! StringT(),
    
    //Type testing
    //Int: arithbasic: +-*/% bit: &|^~<<>> comp2: <!=>
    IntTS()  <test! IsType(),
    IntTS()  <test! IsNumeric(),
    IntTS()  <test! CanCompare(),
    IntTS()  <test! CanCompareOrdered(),
    IntTS()  <test! CanArithBasic(),
    IntTS()  <test! CanBitwiseOps(),
    
    //Uint: arithbasic: +-*/%** bit: &|^~<<>> comp2: <!=>
    UIntTS() <test! IsType(),
    UIntTS() <test! IsNumeric(),
    UIntTS() <test! CanCompare(),
    UIntTS() <test! CanCompareOrdered(),
    UIntTS() <test! CanArithBasic(),
    UIntTS() <test! CanPow(),
    UIntTS() <test! CanBitwiseOps(),
 
    //Fixed: arithbasic: +-*/% comp2: <!=>
    FixedTS()  <test! IsType(),
    FixedTS()  <test! IsNumeric(),
    FixedTS()  <test! CanCompare(),
    FixedTS()  <test! CanCompareOrdered(),
    FixedTS()  <test! CanArithBasic(),
    
    //UFixed: arithbasic: +-*/% comp2: <!=>
    UFixedTS() <test! IsType(),
    UFixedTS() <test! IsNumeric(),
    UFixedTS() <test! CanCompare(),
    UFixedTS() <test! CanCompareOrdered(),
    UFixedTS() <test! CanArithBasic(),
    
    //Address: comp2: <!=>
    AddressT() <test! IsType(),
    AddressT() <test! CanCompare(),
    AddressT() <test! CanCompareOrdered(),
    
    //BytesN: bit: &|^~<<>> comp2: <!=> index: []
    FBytesTS() <test! IsType(),
    FBytesTS() <test! CanBitwiseOps(),
    FBytesTS() <test! CanCompare(),
    FBytesTS() <test! CanCompareOrdered(),
    FBytesTS() <test! CanIndex(),
    
    //DBytes: comp1: != index: []
    DBytesT() <test! IsType(),
    DBytesT() <test! CanCompare(),
    DBytesT() <test! CanIndex(),
    
    //Casting string -> bytes
    StringT() <test! IsType(),
    
    NamedTS() <test! IsType(),
    
    //Arrays can be indexed
    FArrayTS() <test! IsType(),
    FArrayTS() <test! CanIndex(),
    DArrayTS() <test! IsType(),
    DArrayTS() <test! CanIndex().

  [[ p@Program(elements) ^ (programScope) ]] :=
    //More subtyping relations
    SubNumberLiterals [[ p ^ (programScope) ]],
    SubStringLiterals [[ p ^ (programScope) ]],
    SubByteArrays     [[ p ^ (programScope) ]],
    SubIntegers       [[ p ^ (programScope) ]],
    SubAddresses      [[ p ^ (programScope) ]],
    SubVar            [[ p ^ (programScope) ]],
    
    //Add globals
    Globals [[ p ^ (programScope) ]],
    
    InitVisibility [[ p ^ (programScope) ]],
    
    Map1 [[ elements ^ (programScope) ]],
    
    distinct/name D(programScope)/Import         | error $[Two imports with the same name: [NAME]] @NAMES,
    distinct/name D(programScope)/TypeReferrable | error $[Duplicate type [NAME]] @NAMES.
  