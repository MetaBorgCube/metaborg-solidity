module analysis/solidity

imports

  signatures/-
  desugar/numbers
  
  analysis/types
  
  analysis/contracts
  analysis/enums
  analysis/events
  analysis/expressions
  analysis/functionmodifiers
  analysis/functions
  analysis/globals
  analysis/interfaces
  analysis/libraries
  analysis/modifiers
  analysis/modifiertypes
  analysis/pragmas
  analysis/solimports
  analysis/statements
  analysis/statevariables
  analysis/structs
  analysis/usingfor
  analysis/vars
  
  analysis/subtypes/addresses
  analysis/subtypes/bytearrays
  analysis/subtypes/integers
  analysis/subtypes/numberliterals
  analysis/subtypes/stringliterals
  analysis/subtypes/vars

signature
  name resolution
    labels
      P I

    order
      // Check local declarations over imports and parents
      D < P,
      D < I,
      
      // Check imports before parents
      I < P

    well-formedness
      // P* I*   gives: D < PD < PI+D       = Local (var/param) over parent (field/function/contract) over super (super field/super function)
      //                PPD                 = Contract lookup (Function -> Contract -> Program -> Contract Definition)
      (P* I*)

  sorts
    NaBLBool
    TypeTest
  
  constructors
    //True/false placeholders
    NaBLFalse : NaBLBool
    NaBLTrue  : NaBLBool
    
    //Different checks
    IsType            : TypeTest
    IsNumeric         : TypeTest
    CanCompare        : TypeTest
    CanCompareOrdered : TypeTest
    CanArithBasic     : TypeTest
    CanPow            : TypeTest
    CanBitwiseOps     : TypeTest
    CanIndex          : TypeTest
    
  relations
    /**
     * Normal subtyping relation.
     */
    reflexive, anti-symmetric, transitive sub  : Type * Type {
      [+sub],
      FArrayT(+sub),
      DArrayT(+sub),
      TupleT(+sub)
    }
    
    /**
     * Relation for checking visibility rules.
     */
    reflexive, anti-symmetric, transitive vissub : VisibilityType * VisibilityType {
      [+vissub]
    }
    
    /**
     * For checking various properties of a simplified type.
     */
    anti-symmetric, anti-transitive test : Type * TypeTest
    
    /**
     * For casting a type to another type. Casting to the same type is always allowed.
     */
    reflexive cast : Type * Type
  
  functions
  
    /**
     * Returns NaBLFalse if the given term is zero.
     * Returns NaBLTrue otherwise (term is non-zero).
     */
    notZeroConst: Term -> NaBLBool {
      IntLiteral("0", _, _) -> NaBLFalse(),
      IntLiteral(i,   _, _) -> NaBLTrue(),
      exp                   -> NaBLTrue()
    }
    
    /**
     * Returns NaBLFalse if the given term is negative.
     * Returns NaBLTrue otherwise (term is positive).
     */
    notNegativeConst: Term -> NaBLBool {
      IntLiteral(i, _, None()) -> NaBLFalse(),
      IntLiteral(i, _, _)      -> NaBLTrue(),
      exp                      -> NaBLTrue()
    }
    
    /**
     * Throws away type specicality information, e.g. int8 -> int and bytes32 -> bytes.
     */
    simplifyType: Type -> Type {
      IntT(i)            -> IntTS(),
      UIntT(i)           -> UIntTS(),
      NrT(i, 0)          -> IntTS(),
      NrT(i, u)          -> UIntTS(), //Simplify NrT to UInt, as UInt can be used in more places
      FractT(_, _, _, _) -> UFixedTS(),
      FBytesT(i)         -> FBytesTS(),
      FixedT(m, n)       -> FixedTS(),
      UFixedT(m, n)      -> UFixedTS(),
      NamedT(o, st)      -> NamedTS(),
      
      FArrayT(_, _)      -> FArrayTS(),
      DArrayT(_)         -> DArrayTS(),
      other              -> other
    }
    
    /**
     * Determines the type of the elements in an array.
     */
    arrayType: Type -> Type {
      FBytesT(_)    -> NrT(8, 8),
      DBytesT()     -> NrT(8, 8),
      FArrayT(t, _) -> t,
      DArrayT(t)    -> t
    }
    
    /*
     * Convert type to an unsigned type, or returns the original type.
     */
    toUnsigned: Type -> Type {
      UIntT(i)           -> UIntT(i),      //Already an UInt
      NrT(i, 0)          -> NrT(i, 0),     //Not valid as UInt
      NrT(_, u)          -> UIntT(u),      //Valid as UInt
      FractT(_, _, m, n) -> UFixedT(m, n), //Valid as UFixed
      ty                 -> ty             //Invalid
    }
    
    /**
     * Converts type to a signed type, or returns the original type.
     */
    toSigned: Type -> Type {
      IntT(i)            -> IntT(i),
      NrT(i, _)          -> IntT(i),
      FractT(m, n, _, _) -> FixedT(m, n),
      ty                 -> ty
    }

rules

  init ^ (programScope) :=
    new programScope,
    
    //Casting int -> int/uint ; uint -> int/uint
    IntTS()  <cast! IntTS(),
    UIntTS() <cast! IntTS(),
    IntTS()  <cast! UIntTS(),
    UIntTS() <cast! UIntTS(),
    
    //Casting string -> bytes
    DBytesT() <cast! StringT(),
    
    //Type testing
    //Int: arithbasic: +-*/% bit: &|^~<<>> comp2: <!=>
    IntTS()  <test! IsType(),
    IntTS()  <test! IsNumeric(),
    IntTS()  <test! CanCompare(),
    IntTS()  <test! CanCompareOrdered(),
    IntTS()  <test! CanArithBasic(),
    IntTS()  <test! CanBitwiseOps(),
    
    //Uint: arithbasic: +-*/%** bit: &|^~<<>> comp2: <!=>
    UIntTS() <test! IsType(),
    UIntTS() <test! IsNumeric(),
    UIntTS() <test! CanCompare(),
    UIntTS() <test! CanCompareOrdered(),
    UIntTS() <test! CanArithBasic(),
    UIntTS() <test! CanPow(),
    UIntTS() <test! CanBitwiseOps(),
 
    //Fixed: arithbasic: +-*/% comp2: <!=>
    FixedTS()  <test! IsType(),
    FixedTS()  <test! IsNumeric(),
    FixedTS()  <test! CanCompare(),
    FixedTS()  <test! CanCompareOrdered(),
    FixedTS()  <test! CanArithBasic(),
    
    //UFixed: arithbasic: +-*/% comp2: <!=>
    UFixedTS() <test! IsType(),
    UFixedTS() <test! IsNumeric(),
    UFixedTS() <test! CanCompare(),
    UFixedTS() <test! CanCompareOrdered(),
    UFixedTS() <test! CanArithBasic(),
    
    //Address: comp2: <!=>
    AddressT() <test! IsType(),
    AddressT() <test! CanCompare(),
    AddressT() <test! CanCompareOrdered(),
    
    //BytesN: bit: &|^~<<>> comp2: <!=> index: []
    FBytesTS() <test! IsType(),
    FBytesTS() <test! CanBitwiseOps(),
    FBytesTS() <test! CanCompare(),
    FBytesTS() <test! CanCompareOrdered(),
    FBytesTS() <test! CanIndex(),
    
    //DBytes: comp1: != index: []
    DBytesT() <test! IsType(),
    DBytesT() <test! CanCompare(),
    DBytesT() <test! CanIndex(),
    
    //Casting string -> bytes
    StringT() <test! IsType(),
    
    NamedTS() <test! IsType(),
    
    //Arrays can be indexed
    FArrayTS() <test! IsType(),
    FArrayTS() <test! CanIndex(),
    DArrayTS() <test! IsType(),
    DArrayTS() <test! CanIndex().

  [[ p@Program(elements) ^ (programScope) ]] :=
    //Add the subtyping relations
    SubNumberLiterals [[ p ^ (programScope) ]],
    SubStringLiterals [[ p ^ (programScope) ]],
    SubByteArrays     [[ p ^ (programScope) ]],
    SubIntegers       [[ p ^ (programScope) ]],
    SubAddresses      [[ p ^ (programScope) ]],
    SubVar            [[ p ^ (programScope) ]],
    
    Globals           [[ p ^ (programScope) ]],
    
    InitVisibility    [[ p ^ (programScope) ]],
    
    Map1 [[ elements ^ (programScope) ]],
    
    distinct/name D(programScope)/Import         | error $[Two imports with the same name: [NAME]] @NAMES,
    distinct/name D(programScope)/TypeReferrable | error $[Duplicate type [NAME]] @NAMES.
  