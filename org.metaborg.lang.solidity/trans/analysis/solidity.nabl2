module analysis/solidity

imports

  signatures/-
  desugar/numbers
  
  analysis/contracts
  analysis/expressions
  analysis/functions
  analysis/globals
  analysis/interfaces
  analysis/libraries
  analysis/statements
  analysis/statevariables
  analysis/structs
  analysis/types
  analysis/vars
  
  analysis/subnrt

signature
  name resolution
    labels
      // P = Parent (method -> class, class -> program)
      // I = Import (class -> super)
      // M = Method Parent (method -> class)
      // J = Method Import (class -> super)
      P I M J

    order
      // Check local declarations over imports and parents
      D < P,
      D < I,
      
      // Check imports before parents
      I < P,
      
      // J is used for method overriding
      J < D,
      J < I

    well-formedness
      // P* I*   gives: D < PD < PI+D       = Local (var/param) over parent (field/method/classname) over import (super field/super method)
      //                PPD                 = Class lookup (Method -> Class -> Program -> Class Definition)
      
      // M J? I* gives: MJD < MD            = Look in direct super before using local
      //                MJD < MIID          = We first check in the direct super class before looking further
      //                MJI{n}D < MJI{n+1}D = Prefer closer super methods, check all the way
      (P* I*) | (M J? I*)

  namespaces
    Import { iname : string }
  
  sorts
    NaBLBool
    TypeTest
  
  constructors
    NaBLFalse : NaBLBool
    NaBLTrue  : NaBLBool
    
    IsType            : TypeTest
    IsNumeric         : TypeTest
    CanCompare        : TypeTest
    CanCompareOrdered : TypeTest
    CanArithBasic     : TypeTest
    CanPow            : TypeTest
    CanBitwiseOps     : TypeTest
    CanIndex          : TypeTest
    
  relations
    reflexive, anti-symmetric, transitive sub  : Type * Type {
      [+sub]
    }
    anti-symmetric, anti-transitive       test : Type * TypeTest
    
    /* ------------------------------> */ cast : Type * Type
  
  functions
  
    notZeroConst: Term -> NaBLBool {
      IntLiteral("0", _, _) -> NaBLFalse(),
      IntLiteral(i,   _, _) -> NaBLTrue(),
      exp                   -> NaBLTrue()
    }
    
    notNegativeConst: Term -> NaBLBool {
      IntLiteral(i, _, None()) -> NaBLFalse(),
      IntLiteral(i, _, _)      -> NaBLTrue(),
      exp                      -> NaBLTrue()
    }
    
    simplifyType: Type -> Type {
      IntT(i)            -> IntTS(),
      UIntT(i)           -> UIntTS(),
      NrT(i, u)          -> UIntTS(), //Simplify NrT to UInt, as UInt can be used in more places
      FractT(_, _, _, _) -> UFixedTS(),
      FBytesT(i)         -> FBytesTS(),
      FixedT(m, n)       -> FixedTS(),
      UFixedT(m, n)      -> UFixedTS(),
      NamedT(o, st)      -> NamedTS(),
      other              -> other
    }
    
    //Convert type to an unsigned type, or returns the original type
    toUnsigned: Type -> Type {
      UIntT(i)           -> UIntT(i),      //Already an UInt
      NrT(i, 0)          -> NrT(i, 0),     //Not valid as UInt
      NrT(_, u)          -> UIntT(u),      //Valid as UInt
      FractT(_, _, m, n) -> UFixedT(m, n), //Valid as UFixed
      ty                 -> ty             //Invalid
    }
    
    //Converts type to a signed type, or returns the original type
    toSigned: Type -> Type {
      IntT(i)            -> IntT(i),
      NrT(i, _)          -> IntT(i),
      FractT(m, n, _, _) -> FixedT(m, n),
      ty                 -> ty
    }
    
//    //Increases the given number by 8
//    plus8: Term -> Term {
//      0   -> 0,  //0 stays 0 (invalid)
//      8   -> 16,
//      16  -> 24,
//      24  -> 32,
//      32  -> 40,
//      40  -> 48,
//      48  -> 56,
//      56  -> 64,
//      64  -> 72,
//      72  -> 80,
//      80  -> 88,
//      88  -> 96,
//      96  -> 104,
//      104 -> 112,
//      112 -> 120,
//      120 -> 128,
//      128 -> 136,
//      136 -> 144,
//      144 -> 152,
//      152 -> 160,
//      160 -> 168,
//      168 -> 176,
//      176 -> 184,
//      184 -> 192,
//      192 -> 200,
//      200 -> 208,
//      208 -> 216,
//      216 -> 224,
//      224 -> 232,
//      232 -> 240,
//      240 -> 248,
//      248 -> 256,
//      256 -> 0 //Becomes invalid number
//    }
//    
//    //Converts the type to the bound
//    tyToNr: Type -> Term {
//      IntT(x)       -> x,
//      UIntT(x)      -> x,
//      FixedT(m, n)  -> [m, n],
//      UFixedT(m, n) -> [m, n],
//      FBytesT(n)    -> n,
//      FArrayT(_, n) -> n,
//      _             -> NaBLFalse() //Invalid
//    }
//    
//    termToTy: (Term * Type) -> Type {
//      (x, IntTS())         -> IntT(x),
//      (x, UIntTS())        -> UIntT(x),
//      ([m, n], FixedTS())  -> FixedT(m, n),
//      ([m, n], UFixedTS()) -> UFixedT(m, n),
//      (x, FBytesTS())      -> FBytesT(x),
//      (x, FArrayTS(aty))   -> FArrayT(x, aty),
//      (_, _)               -> InvalidType()
//    }

rules

  init ^ (programScope) :=
    new programScope,
    
    //Int * Int Subtyping
    IntT(8)    <sub! IntT(16),
    IntT(16)   <sub! IntT(24),
    IntT(24)   <sub! IntT(32),
    IntT(32)   <sub! IntT(40),
    IntT(40)   <sub! IntT(48),
    IntT(48)   <sub! IntT(56),
    IntT(56)   <sub! IntT(64),
    IntT(64)   <sub! IntT(72),
    IntT(72)   <sub! IntT(80),
    IntT(80)   <sub! IntT(88),
    IntT(88)   <sub! IntT(96),
    IntT(96)   <sub! IntT(104),
    IntT(104)  <sub! IntT(112),
    IntT(112)  <sub! IntT(120),
    IntT(120)  <sub! IntT(128),
    IntT(128)  <sub! IntT(136),
    IntT(136)  <sub! IntT(144),
    IntT(144)  <sub! IntT(152),
    IntT(152)  <sub! IntT(160),
    IntT(160)  <sub! IntT(168),
    IntT(168)  <sub! IntT(176),
    IntT(176)  <sub! IntT(184),
    IntT(184)  <sub! IntT(192),
    IntT(192)  <sub! IntT(200),
    IntT(200)  <sub! IntT(208),
    IntT(208)  <sub! IntT(216),
    IntT(216)  <sub! IntT(224),
    IntT(224)  <sub! IntT(232),
    IntT(232)  <sub! IntT(240),
    IntT(240)  <sub! IntT(248),
    IntT(248)  <sub! IntT(256),

    //UInt(X) * UInt(X+8) subtyping
    UIntT(8)   <sub! UIntT(16),
    UIntT(16)  <sub! UIntT(24),
    UIntT(24)  <sub! UIntT(32),
    UIntT(32)  <sub! UIntT(40),
    UIntT(40)  <sub! UIntT(48),
    UIntT(48)  <sub! UIntT(56),
    UIntT(56)  <sub! UIntT(64),
    UIntT(64)  <sub! UIntT(72),
    UIntT(72)  <sub! UIntT(80),
    UIntT(80)  <sub! UIntT(88),
    UIntT(88)  <sub! UIntT(96),
    UIntT(96)  <sub! UIntT(104),
    UIntT(104) <sub! UIntT(112),
    UIntT(112) <sub! UIntT(120),
    UIntT(120) <sub! UIntT(128),
    UIntT(128) <sub! UIntT(136),
    UIntT(136) <sub! UIntT(144),
    UIntT(144) <sub! UIntT(152),
    UIntT(152) <sub! UIntT(160),
    UIntT(160) <sub! UIntT(168),
    UIntT(168) <sub! UIntT(176),
    UIntT(176) <sub! UIntT(184),
    UIntT(184) <sub! UIntT(192),
    UIntT(192) <sub! UIntT(200),
    UIntT(200) <sub! UIntT(208),
    UIntT(208) <sub! UIntT(216),
    UIntT(216) <sub! UIntT(224),
    UIntT(224) <sub! UIntT(232),
    UIntT(232) <sub! UIntT(240),
    UIntT(240) <sub! UIntT(248),
    UIntT(248) <sub! UIntT(256),
    
    //UInt(X) is subtype of Int(X+8)
    UIntT(8)   <sub! IntT(16),
    UIntT(16)  <sub! IntT(24),
    UIntT(24)  <sub! IntT(32),
    UIntT(32)  <sub! IntT(40),
    UIntT(40)  <sub! IntT(48),
    UIntT(48)  <sub! IntT(56),
    UIntT(56)  <sub! IntT(64),
    UIntT(64)  <sub! IntT(72),
    UIntT(72)  <sub! IntT(80),
    UIntT(80)  <sub! IntT(88),
    UIntT(88)  <sub! IntT(96),
    UIntT(96)  <sub! IntT(104),
    UIntT(104) <sub! IntT(112),
    UIntT(112) <sub! IntT(120),
    UIntT(120) <sub! IntT(128),
    UIntT(128) <sub! IntT(136),
    UIntT(136) <sub! IntT(144),
    UIntT(144) <sub! IntT(152),
    UIntT(152) <sub! IntT(160),
    UIntT(160) <sub! IntT(168),
    UIntT(168) <sub! IntT(176),
    UIntT(176) <sub! IntT(184),
    UIntT(184) <sub! IntT(192),
    UIntT(192) <sub! IntT(200),
    UIntT(200) <sub! IntT(208),
    UIntT(208) <sub! IntT(216),
    UIntT(216) <sub! IntT(224),
    UIntT(224) <sub! IntT(232),
    UIntT(232) <sub! IntT(240),
    UIntT(240) <sub! IntT(248),
    UIntT(248) <sub! IntT(256),
    
    //UInt is subtype of Fbytes
    UIntT(8)   <sub! FBytesT(1),
    UIntT(16)  <sub! FBytesT(2),
    UIntT(24)  <sub! FBytesT(3),
    UIntT(32)  <sub! FBytesT(4),
    UIntT(40)  <sub! FBytesT(5),
    UIntT(48)  <sub! FBytesT(6),
    UIntT(56)  <sub! FBytesT(7),
    UIntT(64)  <sub! FBytesT(8),
    UIntT(72)  <sub! FBytesT(9),
    UIntT(80)  <sub! FBytesT(10),
    UIntT(88)  <sub! FBytesT(11),
    UIntT(96)  <sub! FBytesT(12),
    UIntT(104) <sub! FBytesT(13),
    UIntT(112) <sub! FBytesT(14),
    UIntT(120) <sub! FBytesT(15),
    UIntT(128) <sub! FBytesT(16),
    UIntT(136) <sub! FBytesT(17),
    UIntT(144) <sub! FBytesT(18),
    UIntT(152) <sub! FBytesT(19),
    UIntT(160) <sub! FBytesT(20),
    UIntT(168) <sub! FBytesT(21),
    UIntT(176) <sub! FBytesT(22),
    UIntT(184) <sub! FBytesT(23),
    UIntT(192) <sub! FBytesT(24),
    UIntT(200) <sub! FBytesT(25),
    UIntT(208) <sub! FBytesT(26),
    UIntT(216) <sub! FBytesT(27),
    UIntT(224) <sub! FBytesT(28),
    UIntT(232) <sub! FBytesT(29),
    UIntT(240) <sub! FBytesT(30),
    UIntT(248) <sub! FBytesT(31),
    UIntT(256) <sub! FBytesT(32),
    
    
    
    //The following section is generated out of these rules.
    //Basically, since NaBL does not allow wildcards in the different sides,
    //I replace all the wildcards with the possible instantiations.
    
    //Casting int -> int/uint ; uint -> int/uint
    IntTS()  <cast! IntTS(),
    UIntTS() <cast! IntTS(),
    IntTS()  <cast! UIntTS(),
    UIntTS() <cast! UIntTS(),
//    NrTS() <cast! IntTS(),
//    NrTS() <cast! UIntTS(),
    
    
    //Casting string -> bytes
    DBytesT() <cast! StringT(),
    
    //Type testing
    //Int: arithbasic: +-*/% bit: &|^~<<>> comp2: <!=>
    IntTS()  <test! IsType(),
    IntTS()  <test! IsNumeric(),
    IntTS()  <test! CanCompare(),
    IntTS()  <test! CanCompareOrdered(),
    IntTS()  <test! CanArithBasic(),
    IntTS()  <test! CanBitwiseOps(),
    
    //Uint: arithbasic: +-*/%** bit: &|^~<<>> comp2: <!=>
    UIntTS() <test! IsType(),
    UIntTS() <test! IsNumeric(),
    UIntTS() <test! CanCompare(),
    UIntTS() <test! CanCompareOrdered(),
    UIntTS() <test! CanArithBasic(),
    UIntTS() <test! CanPow(),
    UIntTS() <test! CanBitwiseOps(),
 
    //Fixed: arithbasic: +-*/% comp2: <!=>
    FixedTS()  <test! IsType(),
    FixedTS()  <test! IsNumeric(),
    FixedTS()  <test! CanCompare(),
    FixedTS()  <test! CanCompareOrdered(),
    FixedTS()  <test! CanArithBasic(),
    
    //UFixed: arithbasic: +-*/% comp2: <!=>
    UFixedTS() <test! IsType(),
    UFixedTS() <test! IsNumeric(),
    UFixedTS() <test! CanCompare(),
    UFixedTS() <test! CanCompareOrdered(),
    UFixedTS() <test! CanArithBasic(),
    
    //Address: comp2: <!=>
    AddressT() <test! IsType(),
    AddressT() <test! CanCompare(),
    AddressT() <test! CanCompareOrdered(),
    
    //BytesN: bit: &|^~<<>> comp2: <!=> index: []
    FBytesTS() <test! IsType(),
    FBytesTS() <test! CanBitwiseOps(),
    FBytesTS() <test! CanCompare(),
    FBytesTS() <test! CanCompareOrdered(),
    FBytesTS() <test! CanIndex(),
    
    //Casting string -> bytes
    StringT() <test! IsType(),
    
    NamedTS() <test! IsType()
    .


  [[ p@Program(elements) ^ (programScope) ]] :=
    //More subtyping relations
    NumberTypeSubs[[ p ^ (programScope) ]],
    
    Globals [[ p ^ (programScope) ]],
    
    Map1 [[ elements ^ (programScope) ]],
    
    distinct/name D(programScope)/Import         | error $[Two imports with the same name: [NAME]] @NAMES,
    distinct/name D(programScope)/Contract       | error $[Duplicate contract [NAME]] @NAMES,
    distinct/name D(programScope)/Interface      | error $[Duplicate interface [NAME]] @NAMES,
    distinct/name D(programScope)/Library        | error $[Duplicate library [NAME]] @NAMES,
    distinct/name D(programScope)/TypeReferrable | error $[Duplicate type [NAME]] @NAMES.

  //We can ignore pragmas
  [[ Pragma(name, version) ^ (programScope) ]].
  
  //We cannot determine anything from a direct file import
  [[ ImportFromFile(file) ^ (programScope) ]].
    
  
  [[ Import(items, file) ^ (programScope) ]] :=
    Map1 [[ items ^ (programScope) ]].
    
    
  [[ ImportStar(name) ^ (programScope) ]] :=
    TypeReferrable{name} <- programScope,
    Import{name}         <- programScope,
    Import{name}.iname := "*".
  
  [[ ImportItem(name, as) ^ (programScope) ]] :=
    TypeReferrable{as} <- programScope,
    Import{as}         <- programScope,
    Import{as}.iname := name.