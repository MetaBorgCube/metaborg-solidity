module analysis/contracts

imports

  signatures/-
  analysis/types

signature
  namespaces
    Contract
    This

rules
  [[ c@Contract(name, content) ^ (programScope) ]] :=
    //Define contract and type, also make it referrable
    Contract{name}       <- programScope,
    TypeReferrable{name} <- programScope,
    Contract{name}       : contractType !,
    TypeReferrable{name} : contractType !,
    contractType == UserDefT(Contract{name}),
    
    //Create scope
    new contractScope,
    contractScope -P-> programScope,
    
    // Add this
    This{"this" @c} <- contractScope,
    This{"this" @c} : contractType !,
    
    // Resolve content
    Map1 [[ content ^ (contractScope) ]],
    
    // Check contents for duplicate definitions (events and functions can be overloaded)
    distinct/name D(contractScope)/StateVar         | error $[Duplicate state variable [NAME]] @NAMES,
    distinct/name D(contractScope)/FunctionModifier | error $[Duplicate modifier [NAME]] @NAMES,
    distinct/name D(contractScope)/Struct           | error $[Duplicate struct [NAME]] @NAMES,
    distinct/name D(contractScope)/Enum             | error $[Duplicate enum [NAME]] @NAMES,
    distinct/name D(contractScope)/TypeReferrable   | warning $[Duplicate type [NAME]] @NAMES,
    
    Contract{name} =I=> contractScope.
  
  [[ c@ContractInherits(name, inherits, content) ^ (programScope) ]] :=
    //Define contract and type, also make it referrable
     Contract{name}       <- programScope,
    TypeReferrable{name} <- programScope,
    Contract{name}       : contractType !,
    TypeReferrable{name} : contractType !,
    contractType == UserDefT(Contract{name}),
    
    TypeReferrable{name} <- programScope,
    TypeReferrable{name} : contractType !,
    
    new contractScope,
    contractScope -P-> programScope,
    
    // Create this in contract scope
    This{"this" @c} <- contractScope,
//    This{"this" @c} : contractType !,
    
    Map1 [[ content ^ (contractScope) ]],
    
    // Check contents for duplicate definitions (events and functions can be overloaded)
    distinct/name D(contractScope)/StateVar         | error $[Duplicate state variable [NAME]] @NAMES,
    distinct/name D(contractScope)/FunctionModifier | error $[Duplicate modifier [NAME]] @NAMES,
    distinct/name D(contractScope)/Struct           | error $[Duplicate struct [NAME]] @NAMES,
    distinct/name D(contractScope)/Enum             | error $[Duplicate enum [NAME]] @NAMES,
    
    Contract{name} =I=> contractScope,
    
    false | note $[Inherits not yet implemented].

