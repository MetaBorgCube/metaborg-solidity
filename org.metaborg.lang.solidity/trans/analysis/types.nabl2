module analysis/types

imports
  desugar/functions
  signatures/types-sig

signature
  sorts
    Type
  
  constructors
    //Numeric types
    IntT         : INT -> Type
    UIntT        : INT -> Type
    FixedT       : INT * INT -> Type
    UFixedT      : INT * INT -> Type
    
    //More general types for constants
    NrT          : INT * INT -> Type
    FractT       : INT * INT * INT * INT -> Type
    StringLitT   : INT -> Type
    
    //"Simple" types
    BoolT        : Type
    AddressT     : Type
    StringT      : Type
    
    //Byte arrays
    FBytesT      : INT -> Type
    DBytesT      : Type
    
    //Array types
    FArrayT      : Type * INT -> Type
    DArrayT      : Type -> Type
    
    //Function types
    FunctionT    : list(Type) * Type -> Type
    FunctionModT : list(Type) -> Type
    
    //Complex types
    MappingT     : Type * Type -> Type
    TupleT       : list(Type) -> Type
    NamedT       : occurrence * scope * Type -> Type

    //Type kinds
    EnumT        : Type
    EventT       : list(Type) -> Type
    StructT      : Type
    ContractT    : Type
    InterfaceT   : Type
    LibraryT     : Type
    BuiltInT     : Type
    ImportT      : Type
    
    //Special types
    VarT         : Type
    AnyT         : Type
    VoidT        : Type
    PackedT      : Type
    
    //---------------------------------------------------------------------------------------------
    //Simplified types
    IntTS        : Type
    UIntTS       : Type
    FixedTS      : Type
    UFixedTS     : Type
    
    AddressTS    : Type
    
    FBytesTS     : Type
    DBytesTS     : Type
    FArrayTS     : Type
    DArrayTS     : Type
    StringTS     : Type
    
    NamedTS      : Type
    MappingTS    : Type
    FunctionTS   : Type
    
    InvalidType  : Type

  namespaces
    //Something that can be referenced as a type.
    TypeReferrable { origin : occurrence }

rules
  //-----------------------------------------------------------------------------------------------
  //Simple types
  [[ BooleanType() ^ (s) : BoolT()    ]].
  [[ AddressType() ^ (s) : AddressT() ]].
  [[ StringType()  ^ (s) : StringT()  ]].

  //-----------------------------------------------------------------------------------------------
  //Numbers
  [[ IntType(x)  ^ (s) : tyInt  ]] := tyInt == IntT(x).
  [[ UIntType(x) ^ (s) : tyUInt ]] := tyUInt == UIntT(x).
  [[ FixedType(MxN(m, n))  ^ (s) : tyFixed  ]] := tyFixed == FixedT(m, n), VarT() <sub! tyFixed.
  [[ UFixedType(MxN(m, n)) ^ (s) : tyUFixed ]] := tyUFixed == UFixedT(m, n), VarT() <sub! tyUFixed.
  
  //-----------------------------------------------------------------------------------------------
  //Byte arrays
  [[ FixedBytesArrayType(x)  ^ (s) : ty ]] := ty == FBytesT(x).
  [[ DynamicBytesArrayType() ^ (s) : ty ]] := ty == DBytesT().
  
  //-----------------------------------------------------------------------------------------------
  //Arrays
  [[ FixedArrayType(base, sizeExp) ^ (s) : ty ]] :=
    [[ base ^ (s) : baseTy ]],
    [[ sizeExp ^ (s) : sizeTy ]],
    ty == FArrayT(baseTy, 1),
    VarT() <sub! ty,
    
    false | note $[Size is not checked].
  
  [[ DynamicArrayType(base)        ^ (s) : ty ]] :=
    [[ base ^ (s) : baseTy ]],
    ty == DArrayT(baseTy),
    VarT() <sub! ty.
  
  //-----------------------------------------------------------------------------------------------
  //Functions
  [[ FunctionType(args, vis, stateMut, retParam) ^ (s) : tyFunT ]] :=
    [[ retParam ^ (s) : tyRet ]],
    [[ vis      ^ (s) ]],
    [[ stateMut ^ (s) ]],
    Map1T [[ args ^ (s) : tysArgs ]],

    tyFunT == FunctionT(tysArgs, tyRet),
    VarT() <sub! tyFunT.
  
  //Void type is added to fix return type problems
  [[ VoidType() ^ (s) : VoidT() ]].
  
  //Tuple type is used to wrap return types
  [[ TupleType(params) ^ (s) : TupleT(tys) ]] :=
    Map1T [[ params ^ (s) : tys ]].
  
  //-----------------------------------------------------------------------------------------------
  //Mappings
  [[ MappingType(key, value) ^ (s) : tyMapping ]] :=
    [[ key   ^ (s) : tyKey   ]],
    [[ value ^ (s) : tyValue ]],
    tyMapping == MappingT(tyKey, tyValue),
    VarT() <sub! tyMapping.

  //-----------------------------------------------------------------------------------------------
  //User defined types
  [[ UserDefinedType(x) ^ (s) : tyUDef ]] :=
    TypeReferrable{x} -> s,
    TypeReferrable{x} |-> ref | error $[Cannot find any type [x]] @x,
    ref : tyUDef.
  
  