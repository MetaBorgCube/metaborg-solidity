module analysis/functions

imports
  signatures/-
  analysis/types
  analysis/vars

signature
  namespaces
    Function

rules
  [[ AbstractFunction(name, params, mods, retParams) ^ (s) ]] :=
    Function{name} <- s,
    Function{name} : funTy !,
    funTy == FunctionT(paramTys, retTy),
    
    VarT() <sub! funTy,
    
    new funScope,
    funScope -P-> s,
    
    Map1  [[ mods   ^ (funScope) ]],
    Map1T [[ params ^ (funScope) : paramTys ]],
    [[ retParams    ^ (funScope) : retTy ]].
  
  [[ AbstractFunction(name, params, mods, retParams) ^ (s) ]] :=
    Function{name} <- s,
    Function{name} : funTy !,
    funTy == FunctionT(paramTys, retTy),
    
    VarT() <sub! funTy,
    
    new funScope,
    funScope -P-> s,
    
    Map1  [[ mods   ^ (funScope) ]],
    Map1T [[ params ^ (funScope) : paramTys ]],
    [[ retParams    ^ (funScope) : retTy ]].
  
  [[ Function(name, params, mods, retParams, body) ^ (s) ]] :=
    Function{name} <- s,
    Function{name} : funTy !,
    funTy == FunctionT(paramTys, retTy),
    
    VarT() <sub! funTy,
    
    new funScope,
    funScope -P-> s,
    
    distinct/name D(funScope)/Var | error $[Duplicate variable [NAME]] @NAMES,
    
    Map1  [[ mods    ^ (funScope) ]],
    Map1T [[ params  ^ (funScope) : paramTys ]],
    [[ retParams     ^ (funScope) : retTy ]],
    [[ body          ^ (funScope) ]].
  
  //-----------------------------------------------------------------------------------------------
  [[ Constructor(contractName, params, mod, body) ^ (s) ]] :=
    Function{contractName} <- s,
    Function{contractName} : funTy !,
    funTy == FunctionT(paramTys, retTy),
    
    VarT() <sub! funTy,
    
    new funScope,
    funScope -P-> s,
    
    distinct/name D(funScope)/Var | error $[Duplicate variable [NAME]] @NAMES,
    
    
    [[ mod          ^ (funScope) ]],
    Map1T [[ params ^ (funScope) : paramTys ]],
    [[ body         ^ (funScope) ]],
    
    //Resolve return type
    TypeReferrable{contractName} -> s,
    TypeReferrable{contractName} |-> contract | error $[Unable to find contract this constructor belongs to! Name: [contractName]],
    contract : retTy.
  
  [[ ConstructorWithSuper(contractName, params, mod, superName, superCall, body) ^ (s) ]] :=
    Function{contractName} <- s,
    Function{contractName} : funTy !,
    funTy == FunctionT(paramTys, retTy),
    
    VarT() <sub! funTy,
    
    new funScope,
    funScope -P-> s,
    
    distinct/name D(funScope)/Var | error $[Duplicate variable [NAME]] @NAMES,
    
    [[ mod          ^ (funScope) ]],
    Map1T [[ params ^ (funScope) : paramTys ]],
    [[ body         ^ (funScope) ]],
    
    //Resolve return type
    TypeReferrable{contractName} -> s,
    TypeReferrable{contractName} |-> contract | error $[Unable to find contract this constructor belongs to! Name: [contractName]],
    contract : retTy,

    false | warning $[Super call and super are not yet implemented! Super: [superName]].
