module analysis/functions

imports
  signatures/-
  analysis/vars

signature
  namespaces
    Function

rules
  [[ AbstractFunction(name, params, mods, retParams) ^ (s) ]] :=
    //Declare
    Function{name} <- s,
    Function{name} : FunctionT(paramTys, retTys) !,
    
    //Scope
    new funScope,
    funScope -P-> s,
    
    //Resolve parameters and body
    Map1T [[ params    ^ (funScope) : paramTys ]],
    Map1T [[ retParams ^ (funScope) : retTys   ]].
  
  [[ Function(name, params, mods, retParams, body) ^ (s) ]] :=
    //Declare
    Function{name} <- s,
    Function{name} : FunctionT(paramTys, retTys) !,
    
    //Scope
    new funScope,
    funScope -P-> s,
    
    //Check duplicate variables
    distinct/name D(funScope)/Var | error $[Duplicate variable [NAME]] @NAMES,
    
    Map1T [[ params    ^ (funScope) : paramTys ]],
    Map1T [[ retParams ^ (funScope) : retTys   ]],
    [[ body ^ (funScope) ]].
  
  //-----------------------------------------------------------------------------------------------
  [[ Constructor(contractName, params, mod, body) ^ (s) ]] :=
    //Declare
    Function{contractName} <- s,
    Function{contractName} : FunctionT(paramTys, [retTy]) !,
    
    //Scope
    new funScope,
    funScope -P-> s,
    
    //Check duplicate variables
    distinct/name D(funScope)/Var | error $[Duplicate variable [NAME]] @NAMES,
    
    //Resolve parameters and body
    Map1T [[ params ^ (funScope) : paramTys ]],
    [[ body ^ (funScope) ]],
    
    //TODO Return void in constructor is allowed! Currently breaks (does not return correct type)
    
    //Resolve return type
    TypeReferrable{contractName} -> s,
    TypeReferrable{contractName} |-> contract | error $[Unable to find contract this constructor belongs to! Name: [contractName]],
    contract : retTy.
  
  //TODO Constructor with super
  //ConstructorWithSuper : String * List(Param) * Option(ConsMod) * String * List(Exp) * Statement -> Function
  [[ ConstructorWithSuper(contractName, params, mod, superName, superCall, body) ^ (s) ]] :=
    //Declare
    Function{contractName} <- s,
    Function{contractName} : FunctionT(paramTys, [retTy]) !,
    
    //Scope
    new funScope,
    funScope -P-> s,
    
    //Check duplicate variables
    distinct/name D(funScope)/Var | error $[Duplicate variable [NAME]] @NAMES,
    
    //Resolve parameters and body
    Map1T [[ params ^ (funScope) : paramTys ]],
    [[ body ^ (funScope) ]],
    
    //TODO Return void in constructor is allowed! Currently breaks (does not return correct type)
    
    //Resolve return type
    TypeReferrable{contractName} -> s,
    TypeReferrable{contractName} |-> contract | error $[Unable to find contract this constructor belongs to! Name: [contractName]],
    contract : retTy,
    
    false | warning $[Super call and super are not yet implemented! Super: [superName]].

  //-----------------------------------------------------------------------------------------------
  //OLD:
//  [[ Function(name, params, mods, retParams, body, returnExp) ^ (s) ]] :=
//	//Declare
//    Function{name} <- s,
//    Function{name} : FunctionT(paramTys, retTys) !,
//    
//    //Scope
//    new funScope,
//    funScope -P-> s,
//    
//    //Check duplicate variables
//    distinct/name D(funScope)/Var | error $[Duplicate variable [NAME]] @NAMES,
//    
//    //Resolve parameters and body
//    Map1T [[ params    ^ (funScope) : paramTys ]],
//    Map1T [[ retParams ^ (funScope) : retTys   ]],
//    Map1  [[ body ^ (funScope) ]],
//    [[ returnExp ^ (funScope) : actualRetTys ]],
//    
//    //Check if return type matches
//    //TODO Turn into subtype relation?
//    [actualRetTys] <sub? retTys | error $[[actualRetTys] is not a subtype of the specified return type [retTys]] @returnExp.
  
//  [[ VoidFunction(name, params, mods, body) ^ (s) ]] :=
//	//Declare
//    Function{name} <- s,
//    Function{name} : FunctionT(paramTys, []) !,
//    
//    //Scope
//    new funScope,
//    funScope -P-> s,
//    
//    //Check duplicate variables
//    distinct/name D(funScope)/Var | error $[Duplicate variable [NAME]] @NAMES,
//    
//    //Resolve parameters and body
//    Map1T [[ params    ^ (funScope) : paramTys ]],
//    Map1  [[ body ^ (funScope) ]].
  
//  [[ Constructor(params, mod, body) ^ (s) ]] :=
//    //TODO Determine name of the constructor for name and return type
//    //Declare
//    Function{"constructor"} <- s,
//    Function{"constructor"} : FunctionT(paramTys, retTy) !,
//    
//    //Scope
//    new funScope,
//    funScope -P-> s,
//    
//    //Resolve parameters and body
//    Map1T [[ params ^ (funScope) : paramTys ]],
//    Map1 [[ body ^ (funScope) ]].
//    //...
  