module analysis/globals

imports
  analysis/types

rules
  //We define globals in two separate scopes, to avoid name conflicts.
  GlobalsStart [[ p ^ (programScope) ]] :=
    new globalsAScope,
    programScope -P-> globalsAScope,
    
    Globals [[ p ^ (globalsAScope) ]],
    
    new globalsBScope,
    programScope -P-> globalsBScope,
    
    Globals2 [[ p ^ (globalsBScope) ]].

  Globals [[ p ^ (programScope) ]] :=
    //---------------------------------------------------------------------------------------------
    //abi: encode(...), encodePacked(...), encodeWithSelector(selector, ...), encodeWithSignature(signature, ...)
    new abiScope,
    abiScope -P-> programScope,
    Var{"abi" @p} <- programScope,
    Var{"abi" @p} : tyAbi,
    Var{"abi" @p} =I=> abiScope,
    tyAbi == NamedT(Var{"abi" @p}, BuiltInT()),
    
    Function{"encode"} <- abiScope,
    Function{"encode"} : FunctionT([ VarT() ], VoidT()) !!,
    
    Function{"encodePacked"} <- abiScope,
    Function{"encodePacked"} : FunctionT([ VarT() ], VoidT()) !!,
    
    Function{"encodeWithSelector"} <- abiScope,
    Function{"encodeWithSelector"} : FunctionT([ VarT(), VarT() ], VoidT()) !!,
    
    Function{"encodeWithSignature"} <- abiScope,
    Function{"encodeWithSignature"} : FunctionT([ VarT(), VarT() ], VoidT()) !!,
    
    //---------------------------------------------------------------------------------------------
    //msg: data, gas, sender, value
    new msgScope,
    msgScope -P-> programScope,
    Var{"msg" @p} <- programScope,
    Var{"msg" @p} : tyMsg,
    Var{"msg" @p} =I=> msgScope,
    tyMsg == NamedT(Var{"msg" @p}, BuiltInT()),
    
    Var{"data"} <- msgScope,
    Var{"data"} : DBytesT() !!,
    
    Var{"gas"} <- msgScope,
    Var{"gas"} : UIntT(256) !!,
    
    Var{"sender"} <- msgScope,
    Var{"sender"} : AddressT() !!,
    
    Var{"value"} <- msgScope,
    Var{"value"} : UIntT(256) !!,
    
    //---------------------------------------------------------------------------------------------
    //block: coinbase, difficulty, gaslimit, number, timestamp, blockhash(nr)
    new blockScope,
    blockScope -P-> programScope,
    Var{"block" @p} <- programScope,
    Var{"block" @p} : tyBlock,
    Var{"block" @p} =I=> blockScope,
    tyBlock == NamedT(Var{"block" @p}, BuiltInT()),
    
    Var{"coinbase"} <- blockScope,
    Var{"coinbase"} : AddressT() !!,
    
    Var{"difficulty"} <- blockScope,
    Var{"difficulty"} : UIntT(256) !!,
    
    Var{"gaslimit"} <- blockScope,
    Var{"gaslimit"} : UIntT(256) !!,
    
    Var{"number"} <- blockScope,
    Var{"number"} : UIntT(256) !!,
    
    Var{"timestamp"} <- blockScope,
    Var{"timestamp"} : UIntT(256) !!,
    
    Function{"blockhash"} <- blockScope,
    Function{"blockhash"} : FunctionT([ UIntT(256) ], FBytesT(32)) !!,
    
    //---------------------------------------------------------------------------------------------
    //tx: gasprice, origin
    new txScope,
    txScope -P-> programScope,
    Var{"tx" @p} <- programScope,
    Var{"tx" @p} : tyTx,
    Var{"tx" @p} =I=> txScope,
    tyTx == NamedT(Var{"tx" @p}, BuiltInT()),
    
    Var{"gasprice"} <- txScope,
    Var{"gasprice"} : UIntT(256) !!,
    
    Var{"origin"} <- txScope,
    Var{"origin"} : AddressT() !!,
    
    //---------------------------------------------------------------------------------------------
    //Global functions and variables
    Function{"assert"} <- programScope,
    Function{"assert"} : FunctionT([ BoolT() ], VoidT()) !!,
    
    Function{"gasleft"} <- programScope,
    Function{"gasleft"} : FunctionT([], UIntT(256)) !!,
    
    Var{"now"} <- programScope,
    Var{"now"} : UIntT(256) !!,
    
    Function{"require"} <- programScope,
    Function{"require"} : FunctionT([ BoolT(), StringT() ], VoidT()) !!,
    
    Function{"revert"} <- programScope,
    Function{"revert"} : FunctionT([ StringT() ], VoidT()) !!,
    
    //---------------------------------------------------------------------------------------------
    //Hashing functions
    //keccak256, sha3, sha256 and ripemd160 accepts tightly-packed arguments, so we accept var
    Function{"keccak256"} <- programScope,
    Function{"keccak256"} : tyHashFun !!,
    tyHashFun == FunctionT([ VarT() ], FBytesT(32)),
    
    Function{"sha3"} <- programScope,
    Function{"sha3"} : tyHashFun !!,
    
    Function{"sha256"} <- programScope,
    Function{"sha256"} : tyHashFun !!,
    
    Function{"ripemd160"} <- programScope,
    Function{"ripemd160"} : tyHashFun !!,
    
    Function{"selfdestruct"} <- programScope,
    Function{"selfdestruct"} : tyDestruct !!,
    tyDestruct == FunctionT([ AddressT() ], VoidT()),
    
    Function{"suicide"} <- programScope,
    Function{"suicide"} : tyDestruct !!.
    
  //Define additional functions in a separate scope. If function overloading is fixed, these will work.
  Globals2 [[ p ^ (programScope) ]] :=
    Function{"blockhash"} <- programScope,
    Function{"blockhash"} : FunctionT([ UIntT(256) ], FBytesT(32)) !!,
    
    Function{"require"} <- programScope,
    Function{"require"} : FunctionT([ BoolT() ], VoidT()) !!,
    
    Function{"revert"} <- programScope,
    Function{"revert"} : FunctionT([], VoidT()) !!.