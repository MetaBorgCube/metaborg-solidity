/**
 * This file includes all methods for keeping track of the stack.
 */
module codegen/stack

imports
  signatures/ebc/-

rules
  //---------------------------------------------------------------------------
  //Associative list
  //---------------------------------------------------------------------------
  
  /**
   * Creates a new stack.
   *
   * @return list(tuple(string, int))
   */
  createStackA = ![]

  /**
   * Gets the position of the given item from the stack.
   * This strategy fails if the given name is not in the stack.
   *
   * @param  list(tuple(string, int)) - the stack
   * @param  string                   - the name of the variable
   * @return int                      - the index
   */
  getPositionA(|stack, name) = <lookup> (name, stack)
  
  /**
   * Retrieves the maximum index in the stack.
   * Returns 0 if the stack is empty.
   *
   * @param  list(tuple(string, int)) - the stack
   * @return int                      - the highest index in the stack
   */
  maxStackA(|stack) = <foldr(!0, max)> <map(\ (name, idx) -> idx \)> stack
  
  /**
   * Adds the given name to the stack at a new index.
   *
   * @param  list(tuple(string, int)) - the stack
   * @param  string                   - the name of the item to add
   * @return list(tuple(string, int)) - the updated stack
   */
  addToStackA(|stack, name) = <conc> ([(name, <inc> <maxStackA(|stack)>)], stack)
  
  /**
   * Removes the item with the given name from the stack.
   *
   * @param  list(tuple(string, int)) - the stack
   * @param  string                   - the name of the item to remove
   * @return list(tuple(string, int)) - the updated stack
   */
  removeFromStackA(|stack, name) = <removeFirst(|name)> stack

  /**
   * Removes the first tuple with the given name from the list (current).
   * If the element is not in the list, it is returned unchanged.
   *
   * @param  string                 - the name
   * @param  list(tuple(string, _)) - the list (current)
   * @return list(tuple(string, _)) - the updated list
   */
  removeFirst(|name): []                  -> []
  removeFirst(|name): [(name, _) | tail] -> tail
  removeFirst(|name): [_ | tail]          -> <removeFirst(|name)> tail

  //---------------------------------------------------------------------------
  //HashTable
  //---------------------------------------------------------------------------
  
  /**
   * Creates a new stack.
   *
   * @return HashTable(string, int)
   */
  createStackH = new-hashtable

  /**
   * Gets the position of the given item from the stack.
   * This strategy fails if the given name is not in the stack.
   *
   * @param  HashTable(string, int) - the stack
   * @param  string                 - the name of the variable
   * @return int                    - the index
   */
  getPositionH(|stack, name) = <hashtable-get(|name)> stack
  
  /**
   * Returns the number of elements in the stack.
   *
   * @param  HashTable(_, _) - the stack
   * @return int             - the length of the stack
   */
  stackLengthH(|stack) = <length> <hashtable-values> stack
  
  /**
   * Retrieves the maximum index in the stack.
   * Returns 0 if the stack is empty.
   *
   * @param  HashTable(string, int) - the stack
   * @return int                    - the highest index in the stack
   */
  maxStackH(|stack) = <foldr(!0, max)> <hashtable-values> stack
  
  /**
   * Adds the given name to the stack at a new index.
   *
   * @param  HashTable(string, int) - the stack
   * @param  string                 - the name of the item to add
   * @return HashTable(string, int) - the updated stack
   */
  addToStackH(|stack, name) = <hashtable-put(|name, <inc> <maxStackH(|stack)>)> stack
  
  /**
   * Removes the item with the given name from the stack.
   *
   * @param  HashTable(string, int) - the stack
   * @param  string                 - the name of the item to remove
   * @return HashTable(string, int) - the updated stack
   */
  removeFromStackH(|stack, name) = <hashtable-remove(|name)> stack

  //---------------------------------------------------------------------------
  //Indexed set
  //---------------------------------------------------------------------------
  
  /**
   * Creates a new stack.
   *
   * @return IndexedSet(string)
   */
  createStackI = new-iset

  /**
   * Gets the position of the given item from the stack.
   * This strategy fails if the given name is not in the stack.
   *
   * @param  IndexedSet(string) - the stack
   * @param  string             - the name of the variable
   * @return int                - the index
   */
  getPositionI(|stack): name -> <iset-get-index(|name)> stack
  
  /**
   * Checks if the given name is in the stack.
   * This strategy fails if the given name is not in the stack.
   *
   * @param  IndexedSet(string) - the stack
   * @param  string             - the name of the variable
   */
  isInStackI(|stack): name -> <iset-contains(|name)> stack
  
  /**
   * Returns the number of elements in the stack.
   *
   * @param  IndexedSet(_) - the stack
   * @return int           - the length of the stack
   */
  stackLengthI(|stack) = <length> <iset-elements> stack
  
  /**
   * Adds the given name to the stack at a new index.
   *
   * @param  IndexedSet(string) - the stack
   * @param  string             - the name of the item to add
   * @return IndexedSet(string) - the updated stack
   */
  addToStackI(|stack): name -> <iset-add(|name)> stack
  
  /**
   * Removes the item with the given name from the stack.
   * If the item is not in the stack, the stack is left unchanged.
   *
   * @param  IndexedSet(string) - the stack
   * @param  string             - the name of the item to remove
   * @return IndexedSet(string) - the updated stack
   */
  removeFromStackI(|stack): name -> <iset-remove(|name)> stack
  
  
  //TODO implement something to be able to pop elements from the stack
  popFromStack(|stack) = id

  //Whenever we want to return variable X, we do the following:
  //- Pop until X is on top
  //- n = stack length
  //- If n = 2:  return [ SWAP1(), JUMP() ]
  //- If n < 16: return [ SWAP<n>(), 

  //---------------------------------------------------------------------------
  //Stack functions
  //---------------------------------------------------------------------------
  
  popUntilReturnAddress: stack -> pops
    where
    len := <stackLengthI(|stack)>; 
    if <eq> (1, len)
    then pops := []
    else pops := [ POP() | <popUntilReturnAddress> stack ]
    end
  
  returnName(|stack): name -> []
    where
    len := <stackLengthI(|stack)>
    //TODO: return address is bottom of the stack
    //TODO: return address must get on top of stack
    //TODO: value to return has to be before it on the stack
    //Strategy: pop until we reach the element to return
    //          then