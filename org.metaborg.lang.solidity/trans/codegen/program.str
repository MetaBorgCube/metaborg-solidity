module codegen/program

imports
  nabl2/api
  
  signatures/ebc/-
  ebc/ebcshared/evminstructions
  ebc/ebcshared/codegen

  signatures/-
  desugar/-
  analysis/types
  
  utils/externals
  pp
  
  
  
  libspoofax/stratego/debug

strategies
  /**
   * Repeats strategy s n times.
   * Fails if any of the applications fails.
   */
  do-n(s|n) = (<leq> (n, 0); id) <+ (s; n' := <subti> (n, 1); do-n(s|n'))

overlays
  

rules
  //TODO Pyethereum execution?
  //TODO ABI Generation
  
  //-----------------------------------------------------------------------------------------------
  //Helper methods
  //-----------------------------------------------------------------------------------------------
  
  /**
   * Creates a push instruction of the appropriate size (smallest length fitting the given number).
   */
  //TODO biginteger division instead of integer division
  create-push: nr    -> PUSH(<addi> (<divi> (nr, 256), 1), nr)
  //create-push: nrHex -> PUSH(<addHex> (<divHex> (nrHex, "0x100"), "0x1"), nrHex)
  
  /**
   * Determines the length of the given list of instructions.
   */
  instructions-length: [] -> 0
  instructions-length: [i | is] -> <addi> (<instr-len> i, <instructions-length> is)
  
  /**
   * Returns the length of the given instruction.
   *
   * PUSH<n> = 1 + n
   * PUSHTAG = PUSH2 = 3
   * TAG     = 0
   * OTHERS  = 1
   */
  instr-len: PUSH(n, _)  -> <addi> (n, 1)
  instr-len: PUSHI(n, _) -> <addi> (n, 1)
  instr-len: PUSHTAG(_)  -> 3
  instr-len: TAG(_)      -> 0
  instr-len: _           -> 1
  
  /**
   * Generate the function hash from the function
   */
  hash-signature: Function(name, params, _, _, _)  -> <evm-generate-function-hash> (name, <map(get-param-type-name)> params)
  hash-signature: VoidFunction(name, params, _, _) -> <evm-generate-function-hash> (name, <map(get-param-type-name)> params)
  
  get-param-type-name: Param(type, _, _) -> <pp-solidity-string> type
  
  //uint16  = PUSH FFFF, AND
  //int8    = PUSH 0, SIGNEXTEND
  //int16   = PUSH 1, SIGNEXTEND
  extend-to-32-bytes: BoolT() -> [
    ISZERO(),
    ISZERO()
  ]
  extend-to-32-bytes: IntT(32) -> []
  extend-to-32-bytes: IntT(n)  -> [
    PUSH(1, <divi> (n, 8)),
    SIGNEXTEND()
  ]
  extend-to-32-bytes: UIntT(32) -> []
  extend-to-32-bytes: UIntT(n)  -> [
    PUSH(n', <conc-strings> ("0x", <do-n(append-FF|n')> "") ),
    AND()
  ] where n' := <divi> (n, 8)
  
  append-FF: s -> <conc-strings> (s, "FF")
  
  
  //Fixes "loose" usage of PUSH, PUSHI, SWAP, DUP and LOG
  //PUSH(1, "0x10") -> PUSH("1", "0x10")
  fix-numbers: PUSH(i, nr)  -> PUSH(<int-to-string> i, nr)
    where
    <string-starts-with(|"0x")> nr
  fix-numbers: PUSH(i, nr)  -> PUSH(i', <int-to-hex> nr')
    where
    not(<string-starts-with(|"0x")> nr);
    ((<is-int> i; i' := <int-to-string> i) <+ (i' := i));
    ((<is-int> nr; nr' := nr) <+ (nr' := <string-to-int> nr))
    
  //TODO Should be pairs of nrs
  //PUSHI(1, 0) -> PUSH("1", "0x0")
  fix-numbers: PUSHI(i, nr) -> PUSH(i', <conc-strings> ("0x", <int-to-hex> nr'))
    where
    ((<is-int> i; i' := <int-to-string> i) <+ (i' := i));
    ((<is-int> nr; nr' := nr) <+ (nr' := <string-to-int> nr))
  
  fix-numbers: SWAP(i) -> SWAP(<int-to-string> i)
  fix-numbers: DUP(i)  -> DUP(<int-to-string> i)
  fix-numbers: LOG(i)  -> LOG(<int-to-string> i)
  
  fix-numbers: x -> x
    where
    not(<?PUSH(_, _) + ?PUSHI(_, _) + ?SWAP(_) + ?DUP(_) + ?LOG(_)> x)
  
  //-----------------------------------------------------------------------------------------------
  //Program
  //-----------------------------------------------------------------------------------------------
  //A program consists of a specific "contract load" sequence which loads the actual code of the
  //contract and then jumps into it. 
  program-to-ebc: Program(content) -> [EBCFile(None(), "WIP", Code(<map(fix-numbers)> <concat> [
    [
      //Default initialization (allocate 128 bytes of memory)
      PUSH(1, "0x80"),    //0,1
      PUSH(1, "0x40"),    //2,3
      MSTORE(),           //4
      CALLVALUE(),        //5
      
      //If return of CALLVALUE is zero (success), then jump to tagLoad
      DUP(1),             //6
      ISZERO(),           //7
      PUSHTAG(tagLoad),   //8,910
      JUMPI(),            //11
      
      //Else, REVERT
      PUSH(1, 0),         //12,13
      DUP(1),             //14
      REVERT(),           //15
      
      //TagLoad: Load code
      JUMPDEST(tagLoad),  //16
      POP(),              //17
      <create-push> plen, //18,19,20 [Length of contract code]
      DUP(1),             //21       [???]
      PUSHTAG(tagCode),   //22,23,24 [Begin of contract code]
      PUSH(1, 0),         //25,26    [Start at index 0]
      CODECOPY(),         //27       [Load the code starting at PC x of length l]
      PUSH(1, 0),         //28,29    [Push 0 to signal success]
      RETURN(),           //30       [Return to caller]
      STOP(),             //31
      TAG(tagCode)        //32       [Begin of contract code]
    ],
    code,
    [ STOP() ]
  ]))] where
    <newname> "" => tagCode;
    <newname> "" => tagLoad;
    code := <mapconcat(program-content-to-ebc)> content;
    plen := <instructions-length> code
  
  program-content-to-ebc = pragma-to-ebc
  program-content-to-ebc = import-to-ebc
  program-content-to-ebc = interface-to-ebc
  program-content-to-ebc = library-to-ebc
  program-content-to-ebc = contract-to-ebc
  
  //-----------------------------------------------------------------------------------------------
  //Pragmas
  //-----------------------------------------------------------------------------------------------
  //We can completely ignore pragmas
  pragma-to-ebc: Pragma(_, _) -> []
  
  //-----------------------------------------------------------------------------------------------
  //Imports
  //-----------------------------------------------------------------------------------------------
  //TODO Imports. For now, I just ignore imports
  import-to-ebc: Import(_, _) -> []
  
  //-----------------------------------------------------------------------------------------------
  //Contract-like
  //-----------------------------------------------------------------------------------------------
  //TODO Interfaces
  interface-to-ebc: Interface(name, content) -> [] //TODO
  
  //Treat libraries like contracts
  library-to-ebc: Library(name, content) -> <contract-to-ebc> Contract(name, content)
  
  contract-to-ebc: Contract(name, content) -> <concat> [
    //Allocate 128 bytes 
    [ PUSH(1, "0x80"),
      PUSH(1, "0x40"),
      MSTORE(),
      PUSH(1, 4),
      CALLDATASIZE(),
      LT(),
      PUSHTAG(tagFailHandler),
      JUMPI(),
      PUSH(1, 0),
      
      //Determine the function being called
      CALLDATALOAD(),
      PUSH(29, "0x100000000000000000000000000000000000000000000000000000000"),
      SWAP(1),
      DIV(),
      PUSH(4, "0xFFFFFFFF"),
      AND() ],
    
    selectFunctionSequence,
    
    //Tag Fail Handler: Revert
    [ JUMPDEST(tagFailHandler),
      PUSH(1, 0),
      DUP(1),
      REVERT() ],
    
    //Function definitions
    functionBlocks
    
    //TODO Other content
    //<map(content-to-ebc)> content
      
  ] where
    tagFailHandler := <newname> "";
    
    //Create the code for the functions
    functions := <filter-fun> content;
    <ppdebugna0> functions;
    
    funtuples := <map(fun-to-ebc)> functions;
    
    //The select function sequence is the first element of the tuple, concatenated.
    //It determines which function is selected upon calling
    <ppdebugna1> funtuples;
    selectFunctionSequence := <concat> <map(\ (i, _) -> i \)> funtuples;
    
    //The blocks of instructions for the different functions
    functionBlocks         := <concat> <map(\ (_, f) -> f \)> funtuples;
    <ppdebugna2> functionBlocks
  
  //-----------------------------------------------------------------------------------------------
  //Contract content
  //-----------------------------------------------------------------------------------------------
  //Support statevariables, functions, event, enum and struct definitions
  content-to-ebc = statevar-to-ebc
  content-to-ebc = fun-to-ebc
  content-to-ebc = eventdecl-to-ebc
  content-to-ebc = enumdecl-to-ebc
  content-to-ebc = structdecl-to-ebc
  content-to-ebc = funmoddecl-to-ebc
  
  //-----------------------------------------------------------------------------------------------
  //State variables
  //-----------------------------------------------------------------------------------------------
  
  statevar-to-ebc: StateVariable(ty, mod, name, None())  -> [] //TODO
  statevar-to-ebc: StateVariable(ty, mod, name, Some(e)) -> [] //TODO
  statevar-to-ebc: ConstantStateVariable(ty, mod, name, None())  -> [] //TODO Not supported?
  statevar-to-ebc: ConstantStateVariable(ty, mod, name, Some(e)) -> [] //TODO
  
  //-----------------------------------------------------------------------------------------------
  //Functions
  //-----------------------------------------------------------------------------------------------
  /**
   * Retain only the functions in the given list.
   *
   * @param list
   *
   * @return list
   */
  filter-fun: [] -> []
  filter-fun: [head | tail] -> [head | <filter-fun> tail]
    where
    <?Function(_, _, _, _, _) + ?VoidFunction(_, _, _, _)> head
  filter-fun: [head | tail] -> <filter-fun> tail
    where
    not(<?Function(_, _, _, _, _) + ?VoidFunction(_, _, _, _)> head)
  
  //In the first tag, there is matching of function hashes to their initial jump points
  //All checks after the first need a DUP(1) first.
  
  //Then, there is, for each function, thus a jump point, which initiates the call as follows:
  // 1. check that the CALLVALUE ISZERO, if it is, continue to the next jump point, otherwise revert.
  // 2. 
  
  fun-to-ebc: f@Function(name, params, _, retParams, Block(stmts)) -> (
    //PART1: Check if this is the function being called, and if so, jump to funInit
    [
      DUP(1),
      PUSH(4, <conc-strings> ("0x", <hash-signature> f)), //The hash of the function determines which function is being called.
      EQ(),
      PUSHTAG(tagFunInit),
      JUMPI()
    ],
    
    <concat> [
      //PART2: Check if CALLVALUE is ZERO -> jump to pre, else, REVERT
      [ JUMPDEST(tagFunInit),
        CALLVALUE(),
        DUP(1),
        ISZERO(),
        PUSHTAG(tagFunPre),
        JUMPI(),
        PUSH(1, 0),
        DUP(1),
        REVERT() ],
      
      //PART3: Create stack frame for function (load arguments)
      //0-argument function
      [ JUMPDEST(tagFunPre),
        POP(),
        PUSHTAG(tagFunPost),
        
        //TODO LOAD ARGUMENTS HERE
        
        PUSHTAG(tagFunStart),
        JUMP() ],
      
      /*
      //1-argument function
      <concat> [
        [ JUMPDEST(tagFunPre),
          POP(),
          PUSHTAG(tagFunPost),
          PUSH(0, 4),
          DUP(1),
          CALLDATASIZE(),
          SUB(),
          DUP(2),
          ADD(),
          SWAP(1),
          DUP(1),
          DUP(1),
          CALLDATALOAD() ],
          
          //Extend value to 32 bytes
          <extend-to-32-bytes> type
          
          [ SWAP(1),
          PUSH(1, "0x20"),
          ADD(),
          SWAP(1),
          SWAP(3),
          SWAP(2),
          SWAP(1),
          POP(),
          POP(),
          POP(),
          PUSHTAG(tagFunStart),
          JUMP() ]
      ],
      */
      
      //PART4: store result
      [ JUMPDEST(tagFunPost),
        PUSH(1, "0x40"),
        MLOAD(),
        DUP(1),
        DUP(3),
        PUSH(1, 0),
        SIGNEXTEND(),
        PUSH(1, 0),
        SIGNEXTEND(),
        DUP(2),
        MSTORE(),
        PUSH(1, "0x20"),
        ADD(),
        SWAP(2),
        POP(),
        POP(),
        PUSH(1, "0x40"),
        MLOAD(),
        DUP(1),
        SWAP(2),
        SUB(),
        SWAP(1),
        RETURN() ],
      
      /*
      //For a string return, we get this giant mess
      JUMPDEST(tagFunPost),
      PUSH(1, "0x40"),
      MLOAD(),
      DUP(1),
      DUP(1),
      PUSH(1, "0x20"),
      ADD(),
      DUP(3),
      DUP(2),
      SUB(),
      DUP(3),
      MSTORE(),
      DUP(4),
      DUP(2),
      DUP(2),
      MLOAD(),
      DUP(2),
      MSTORE(),
      PUSH(1, "0x20"),
      ADD(),
      SWAP(2),
      POP(),
      DUP(1),
      MLOAD(),
      SWAP(1),
      PUSH(1, "0x20"),
      ADD(),
      SWAP(1),
      DUP(1),
      DUP(4),
      DUP(4),
      PUSH(0),
      
      //Tag 6: some kind of loop
      JUMPDEST(tag6),
      DUP(4),
      DUP(2),
      LT(),
      ISZERO(),
      PUSHTAG(tag7),
      JUMPI(),
      DUP(1),
      DUP(3),
      ADD(),
      MLOAD(),
      DUP(2),
      DUP(5),
      ADD(),
      MSTORE(),
      PUSH(1, "0x20"),
      DUP(2),
      ADD(),
      SWAP(1),
      POP(),
      PUSHTAG(tag6),
      JUMP()
      
      //Tag7
      JUMPDEST(tag7),
      POP(),
      POP(),
      POP(),
      POP(),
      SWAP(1),
      POP(),
      SWAP(1),
      DUP(2),
      ADD(),
      SWAP(1),
      PUSH(1, "0x1F"),
      AND(),
      DUP(1),
      ISZERO(),
      PUSHTAG(tag9),
      JUMPI(),
      DUP(1),
      DUP(3),
      SUB(),
      DUP(1),
      MLOAD(),
      PUSH(1, 1),
      DUP(4),
      PUSH(1, "0x20"),
      SUB(),
      PUSH(1, "0x100"),
      EXP(),
      SUB(),
      NOT(),
      AND(),
      DUP(2),
      MSTORE(),
      PUSH(1, "0x20"),
      ADD(),
      SWAP(2),
      POP(),
      
      //tag 9
      JUMPDEST(tag9),
      POP(),
      SWAP(3),
      POP(),
      POP(),
      POP(),
      PUSH(1, "0x40"),
      MLOAD(),
      DUP(1),
      SWAP(2),
      SUB(),
      SWAP(1),
      RETURN()
      */
      
      //PART5: Actual function
      <concat> [
        //Return address is on the stack
        [ JUMPDEST(tagFunStart) ],
        //TODO params
        <mapconcat(stmt-to-ebc)> stmts,
        
        //TODO: Swap n-th stack element to move return address to top
        //JUMPS to the element at the top of the stack
        //TODO: POP remaining items on stack until only that which we want to return is left.
        [
          SWAP(1),
          JUMP()
        ]
      ]
    ]
    ) where
    tagFunInit  := <newname> "";
    tagFunPre   := <newname> "";
    tagFunPost  := <newname> "";
    tagFunStart := <newname> ""
    
    //Determine type of function
//    a := <nabl2-get-ast-analysis>;
//    ref-occ := <nabl2-mk-occurrence(|"Function")> name;
//    dec-occ := <nabl2-get-resolved-name(|a); Fst> ref-occ;
//    type    := <nabl2-get-type(|a)> dec-occ;
//    param-types := <param-types> type
    
  
//  fun-to-ebc: Function(name, params, _, retParams, body) -> instr
//    where
//    retlen := <length> retParams;
//    instr := <concat> [
//      //Return address is on the stack
//      [ JUMPDEST() ],
//      //TODO params
//      <mapconcat(stmt-to-ebc)> body,
//      
//      //TODO: Swap n-th stack element to move return address to top
//      //JUMPS to the element at the top of the stack
//      //TODO: POP remaining items on stack until only that which we want to return is left.
//      [
//        SWAP(retlen),
//        JUMP()
//      ]
//    ]
//  
//  fun-to-ebc: VoidFunction(name, params, _, body) -> instr
//    where
//    instr := <concat> [
//      [ JUMPDEST() ],
//      //TODO params
//      <mapconcat(stmt-to-ebc)> body,
//      [ JUMP() ]
//    ]
  
  //-----------------------------------------------------------------------------------------------
  //Events
  //-----------------------------------------------------------------------------------------------
  
  eventdecl-to-ebc: Event(name, params, anonymous) -> [] //TODO
  
  //-----------------------------------------------------------------------------------------------
  //Enums
  //-----------------------------------------------------------------------------------------------
  
  enumdecl-to-ebc: Enum(name, fields) -> [] //TODO
  
  //-----------------------------------------------------------------------------------------------
  //Structs
  //-----------------------------------------------------------------------------------------------
  
  structdecl-to-ebc: Struct(name, fields) -> [] //TODO
  
  //-----------------------------------------------------------------------------------------------
  //Function modifiers
  //-----------------------------------------------------------------------------------------------
  
  funmoddecl-to-ebc: FunctionModifier(name, params, stmts) -> [] //TODO
  
  //-----------------------------------------------------------------------------------------------
  //Statements
  //-----------------------------------------------------------------------------------------------
  stmt-to-ebc = ret-to-ebc(|0)
  
  ret-to-ebc(|stacklen): ReturnStatement(name, e1) -> <concat> [
    <exp-to-ebc> e1,
    //TODO Get function type from NaBL to determine return type
    [ 
      //TODO Empty stack up to return
      //TODO Swap return address up
      SWAP(1),
      JUMP()
    ]
  ] where
    a := <nabl2-get-ast-analysis>;
    ref-occ := <nabl2-mk-occurrence(|"Function")> name;
    dec-occ := <nabl2-get-resolved-name(|a); Fst> ref-occ;
    type    := <nabl2-get-type(|a)> dec-occ;
    ret-type := <return-type> type
  
  ret-to-ebc(|stacklen): r@VoidReturn(name) -> <concat> [
    //TODO Get function type from NaBL to determine how much to pop?
    //TODO Keep track of current stack size to pop properly?
    //TODO Empty stack up to return
    //TODO Swap return address up
  ] where
    a := <nabl2-get-ast-analysis>;
    ref-occ := <nabl2-mk-occurrence(|"Function")> name;
    dec-occ := <nabl2-get-resolved-name(|a); Fst> ref-occ;
    type    := <nabl2-get-type(|a)> dec-occ;
    ret-type := <return-type> type
  
  //-----------------------------------------------------------------------------------------------
  //Expression statements
  //TODO Optional POP?
  stmt-to-ebc: ExpStmt(e1) -> <exp-to-ebc> e1 //TODO Return stack to original length
  
  //-----------------------------------------------------------------------------------------------
  //If statements
  
  //TODO Stack/variable count/other
  stmt-to-ebc: If(e1, trueStmt, Else(elseStmt)) -> instr
    where
    tagFalse   := <newname> "";
    tagAfterIf := <newname> "";
    instr := <concat> [        //
      <exp-to-ebc> e1,         //  PUSH e1
      [ ISZERO(),              //  ISZERO
        PUSHTAG(tagFalse),     //  PUSHTAG tagFalse
        JUMPI() ],             //  JUMPI
      <stmt-to-ebc> trueStmt,  //  <IF-BRANCH>
      [ PUSHTAG(tagAfterIf),   //  PUSHTAG tagAfterIf
        JUMP(),                //  JUMP
                               //tag false
        JUMPDEST(tagFalse) ],  //  JUMPDEST
      <stmt-to-ebc> elseStmt,  //  <ELSE-BRANCH>
      [                        //tag afterIf
        JUMPDEST(tagAfterIf) ] //  JUMPDEST
    ]
  
  //TODO If without else (or desugar away)
  
  //TODO For loops
  
  //TODO While loops
  
  //-----------------------------------------------------------------------------------------------
  //Expressions
  //-----------------------------------------------------------------------------------------------
  
  //TODO Keep stack of stack with map like structure (dictionary)
  //getPosition(name) => number
  //swapToTop(position) => swaps elements such that this element is now at the top
  //setPosition(name, position) (maybe, maybe it shouldn't be?)
  //I can dup the element at position and then write back the result if needed (simplicity)
  
  
  
  //TODO the expression needs to know the target size
  //E.g. int16 x = 10; must become PUSH2 10
  
  
  //Literals
  exp-to-ebc: True()  -> [ PUSH(1, 1) ]
  exp-to-ebc: False() -> [ PUSH(1, 0) ]
  exp-to-ebc: IntLiteral(nr, signed, unsigned) -> [ PUSH(plen, nr) ]
    where
    plen := <divi> (signed, 8)
  
  //TODO Add signed division, signed/unsigned modulo, addmod/mulmod
  
  //not
  exp-to-ebc: UnExp(op, e1) -> <concat> [
    <exp-to-ebc> e1,
    [ <op-to-ebc> op ]
  ]
  
  //+ - * and pow, and, or and xor
  exp-to-ebc: BinExp(op, e1, e2) -> <concat> [
    <exp-to-ebc> e1,
    <exp-to-ebc> e2,
    [ <op-to-ebc> op ]
  ]
  
  //-----------------------------------------------------------------------------------------------
  //Operators
  //-----------------------------------------------------------------------------------------------
  //Simple operators that will work without any other information
  op-to-ebc: Plus()   -> ADD()
  op-to-ebc: Minus()  -> SUB()
  op-to-ebc: Mult()   -> MUL()
  op-to-ebc: Pow()    -> EXP()
  op-to-ebc: BitAnd() -> AND()
  op-to-ebc: BitOr()  -> OR()
  op-to-ebc: BitXor() -> XOR()
  op-to-ebc: BitNot() -> NOT()
  
  //TODO
  
  //-----------------------------------------------------------------------------------------------
  //Nabl types
  //-----------------------------------------------------------------------------------------------
  return-type: FunctionT(_, [retT]) -> retT
  