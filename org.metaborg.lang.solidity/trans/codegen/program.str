module codegen/program

imports
  nabl2/api
  
  signatures/ebc/-

  signatures/-
  
  desugar/-
  
  analysis/types
  
  utils/externals

strategies
  /**
   * Repeats strategy s n times.
   * Fails if any of the applications fails.
   */
  do-n(s|n) = (<leq> (n, 0); id) <+ (s; n' := <subti> (n, 1); do-n(s|n'))

overlays
  

rules
  //TODO Pyethereum execution?
  //TODO ABI Generation
  
  //-----------------------------------------------------------------------------------------------
  //Helper methods
  //-----------------------------------------------------------------------------------------------
  
  /**
   * Creates a push instruction of the appropriate size (smallest length fitting the given number).
   */
  //TODO biginteger division instead of integer division
  create-push: nr    -> PUSH(<addi> (<divi> (nr, 256), 1), nr)
  //create-push: nrHex -> PUSH(<addHex> (<divHex> (nrHex, "0x100"), "0x1"), nrHex)
  
  /**
   * Determines the length of the given list of instructions.
   */
  instructions-length: [] -> 0
  instructions-length: [i | is] -> <addi> (<instr-len> i, <instructions-length> is)
  
  /**
   * Returns the length of the given instruction.
   *
   * PUSH<n> = 1 + n
   * PUSHTAG = PUSH2 = 3
   * TAG     = 0
   * OTHERS  = 1
   */
  instr-len: PUSH(n, _) -> <addi> (n, 1)
  instr-len: PUSHTAG(_) -> 3
  instr-len: TAG(_)     -> 0
  instr-len: _          -> 1
  
  
  //-----------------------------------------------------------------------------------------------
  //Program
  //-----------------------------------------------------------------------------------------------
  //A program consists of a specific "contract load" sequence which loads the actual code of the
  //contract and then jumps into it. 
  program-to-ebc: Program(content) -> <concat> [
    [
      //Default initialization (allocate 128 bytes of memory)
      PUSH(1, "0x80"),    //0,1
      PUSH(1, "0x40"),    //2,3
      MSTORE(),           //4
      CALLVALUE(),        //5
      
      //If return of CALLVALUE is zero (success), then jump to tagLoad
      DUP(1),             //6
      ISZERO(),           //7
      PUSHTAG(tagLoad),   //8,910
      JUMPI(),            //11
      
      //Else, REVERT
      PUSH(1, 0),         //12,13
      DUP(1),             //14
      REVERT(),           //15
      
      //TagLoad: Load code
      JUMPDEST(tagLoad),  //16
      POP(),              //17
      <create-push> plen, //18,19,20 [Length of contract code]
      DUP(1),             //21       [???]
      PUSHTAG(tagCode),   //22,23,24 [Begin of contract code]
      PUSH(1, 0),         //25,26    [Start at index 0]
      CODECOPY(),         //27       [Load the code starting at PC x of length l]
      PUSH(1, 0),         //28,29    [Push 0 to signal success]
      RETURN(),           //30       [Return to caller]
      STOP(),             //31
      TAG(tagCode)        //32       [Begin of contract code]
    ],
    code,
    [
      STOP()
      //TODO FOOTER
    ]
  ] where
    <newname> "" => tagCode;
    <newname> "" => tagLoad;
    code := <mapconcat(program-content-to-ebc)> content;
    plen := <instructions-length> code
  
  program-content-to-ebc = pragma-to-ebc
  program-content-to-ebc = import-to-ebc
  program-content-to-ebc = interface-to-ebc
  program-content-to-ebc = library-to-ebc
  program-content-to-ebc = contract-to-ebc
  
  //-----------------------------------------------------------------------------------------------
  //Pragmas
  //-----------------------------------------------------------------------------------------------
  //We can completely ignore pragmas
  pragma-to-ebc: Pragma(_, _) -> []
  
  //-----------------------------------------------------------------------------------------------
  //Imports
  //-----------------------------------------------------------------------------------------------
  //TODO Imports. For now, I just ignore imports
  import-to-ebc: Import(_, _) -> []
  
  //-----------------------------------------------------------------------------------------------
  //Contract-like
  //-----------------------------------------------------------------------------------------------
  //TODO Interfaces
  interface-to-ebc: Interface(name, content) -> []
  
  //Treat libraries like contracts
  library-to-ebc: Library(name, content) -> <contract-to-ebc> Contract(name, content)
  
  contract-to-ebc: Contract(name, content) -> <concat> [
    //Allocate 128 bytes 
    [ PUSH(1, "0x80"),
      PUSH(1, "0x40"),
      MSTORE(),
      PUSH(1, 4),
      CALLDATASIZE(),
      LT(),
      PUSHTAG(tag1),
      JUMPI(),
      PUSH(1, 0),
      CALLDATALOAD(),
      PUSH(29, "0x100000000000000000000000000000000000000000000000000000000"),
      SWAP(1),
      DIV(),
      PUSH(4, "0xFFFFFFFF"),
      AND(),
      DUP(1),
      PUSH(4, "0xFF020EFE"), //Hash check??
      EQ(),
      PUSHTAG(tag2),
      JUMPI() ],
    
    //Tag 1: Revert
    [ JUMPDEST(tag1),
      PUSH(1, 0),
      DUP(1),
      REVERT() ],
    
    //Tag 2: If deposited amount is zero, then goto 3, else revert
    [ JUMPDEST(tag2),
      CALLVALUE(),
      DUP(1),
      ISZERO(),
      PUSHTAG(tag3),
      JUMPI(),
      PUSH(1, 0),
      DUP(1),
      REVERT() ],
    
    //Tag 3: ???
    [ JUMPDEST(tag3),
      POP(),
      PUSHTAG(tag4),
      PUSH(0, 4),
      DUP(1),
      CALLDATASIZE(),
      SUB(),
      DUP(2),
      ADD(),
      SWAP(1),
      DUP(1),
      DUP(1),
      CALLDATALOAD(),
      SWAP(1),
      PUSH(1, "0x20"),
      ADD(),
      SWAP(1),
      SWAP(3),
      SWAP(2),
      SWAP(1),
      POP(),
      POP(),
      POP(),
      POP(),
      PUSHTAG(tag5),
      JUMP() ],
    
    [ JUMPDEST(tag4) ], //TODO
    [ JUMPDEST(tag5) ],
    
    <map(content-to-ebc)> content
      
  ] where
    tag1 := <new> "";
    tag2 := <new> "";
    tag3 := <new> "";
    tag4 := <new> "";
    tag5 := <new> ""
  
  //-----------------------------------------------------------------------------------------------
  //Contract content
  //-----------------------------------------------------------------------------------------------
  //Support statevariables, functions, event, enum and struct definitions
  content-to-ebc = statevar-to-ebc
  content-to-ebc = fun-to-ebc
  content-to-ebc = eventdecl-to-ebc
  content-to-ebc = enumdecl-to-ebc
  content-to-ebc = structdecl-to-ebc
  
  //-----------------------------------------------------------------------------------------------
  //State variables
  //-----------------------------------------------------------------------------------------------
  
  statevar-to-ebc: StateVariable(ty, mod, name, None()) -> [] //TODO
  statevar-to-ebc: StateVariable(ty, mod, name, Some(e)) -> [] //TODO
  statevar-to-ebc: ConstantStateVariable(ty, mod, name, None()) -> [] //TODO Not supported?
  statevar-to-ebc: ConstantStateVariable(ty, mod, name, Some(e)) -> [] //TODO
  
  //-----------------------------------------------------------------------------------------------
  //Functions
  //-----------------------------------------------------------------------------------------------
  fun-to-ebc: Function(_, params, _, retParams, body) -> instr
    where
    retlen := <length> retParams;
    instr := <concat> [
      //Return address is on the stack
      [ JUMPDEST() ],
      //TODO params
      <mapconcat(stmt-to-ebc)> body,
      
      //TODO: Swap n-th stack element to move return address to top
      //JUMPS to the element at the top of the stack
      //TODO: POP remaining items on stack until only that which we want to return is left.
      [
        SWAP(retlen),
        JUMP()
      ]
    ]
  
  fun-to-ebc: VoidFunction(_, params, _, body) -> instr
    where
    instr := <concat> [
      [ JUMPDEST() ],
      //TODO params
      <mapconcat(stmt-to-ebc)> body,
      [ JUMP() ]
    ]
  
  //-----------------------------------------------------------------------------------------------
  //Events
  //-----------------------------------------------------------------------------------------------
  
  eventdecl-to-ebc: Event(name, params, anonymous) -> [] //TODO
  
  //-----------------------------------------------------------------------------------------------
  //Enums
  //-----------------------------------------------------------------------------------------------
  
  enumdecl-to-ebc: Enum(name, fields) -> [] //TODO
  
  //-----------------------------------------------------------------------------------------------
  //Structs
  //-----------------------------------------------------------------------------------------------
  
  structdecl-to-ebc: Struct(name, fields) -> [] //TODO
  
  //-----------------------------------------------------------------------------------------------
  //Statements
  //-----------------------------------------------------------------------------------------------
  ret-to-ebc(|stacklen): ReturnStatement(name, e1) -> <concat> [
    <exp-to-ebc> e1,
    //TODO Get function type from NaBL to determine return type
    [ 
      //TODO Empty stack up to return
      //TODO Swap return address up
      JUMP()
    
    ]
  ] where
    a := <nabl2-get-ast-analysis>;
    ref-occ := <nabl2-mk-occurrence(|"Function")> name;
    dec-occ := <nabl2-get-resolved-name(|a); Fst> ref-occ;
    type    := <nabl2-get-type(|a)> dec-occ;
    ret-type := <return-type> type
  
  ret-to-ebc: r@VoidReturn(name) -> <concat> [
    //TODO Get function type from NaBL to determine how much to pop?
    //TODO Keep track of current stack size to pop properly?
    //TODO Empty stack up to return
    //TODO Swap return address up
  ] where
    a := <nabl2-get-ast-analysis>;
    ref-occ := <nabl2-mk-occurrence(|"Function")> name;
    dec-occ := <nabl2-get-resolved-name(|a); Fst> ref-occ;
    type    := <nabl2-get-type(|a)> dec-occ;
    ret-type := <return-type> type
  
  //-----------------------------------------------------------------------------------------------
  //Expression statements
  //TODO Optional POP?
  stmt-to-ebc: ExpStmt(e1) -> <exp-to-ebc> e1 //TODO Return stack to original length
  
  //-----------------------------------------------------------------------------------------------
  //If statements
  
  //TODO Stack/variable count/other
  stmt-to-ebc: If(e1, trueStmt, Else(elseStmt)) -> instr
    where
    tagFalse   := <newname> "";
    tagAfterIf := <newname> "";
    instr := <concat> [        //
      <exp-to-ebc> e1,         //  PUSH e1
      [ ISZERO(),              //  ISZERO
        PUSHTAG(tagFalse),     //  PUSHTAG tagFalse
        JUMPI() ],             //  JUMPI
      <stmt-to-ebc> trueStmt,  //  <IF-BRANCH>
      [ PUSHTAG(tagAfterIf),   //  PUSHTAG tagAfterIf
        JUMP(),                //  JUMP
                               //tag false
        JUMPDEST(tagFalse) ],  //  JUMPDEST
      <stmt-to-ebc> elseStmt,  //  <ELSE-BRANCH>
      [                        //tag afterIf
        JUMPDEST(tagAfterIf) ] //  JUMPDEST
    ]
  
  //TODO If without else (or desugar away)
  
  //-----------------------------------------------------------------------------------------------
  //Expressions
  //-----------------------------------------------------------------------------------------------
  
  //TODO Keep stack of stack with map like structure (dictionary)
  //getPosition(name) => number
  //swapToTop(position) => swaps elements such that this element is now at the top
  //setPosition(name, position) (maybe, maybe it shouldn't be?)
  //I can dup the element at position and then write back the result if needed (simplicity)
  
  
  
  //TODO the expression needs to know the target size
  //E.g. int16 x = 10; must become PUSH2 10
  
  
  //Literals
  exp-to-ebc: True()  -> [ PUSH(1, "1") ]
  exp-to-ebc: False() -> [ PUSH(1, "0") ]
  exp-to-ebc: IntLiteral(nr, signed, unsigned) -> [ PUSH(plen, nr) ]
    where
    plen := <divi> (signed, 8)
  
  //TODO Add signed division, signed/unsigned modulo, addmod/mulmod
  
  //not
  exp-to-ebc: UnExp(op, e1) -> <concat> [
    <exp-to-ebc> e1,
    [ <op-to-ebc> op ]
  ]
  
  //+ - * and pow, and, or and xor
  exp-to-ebc: BinExp(op, e1, e2) -> <concat> [
    <exp-to-ebc> e1,
    <exp-to-ebc> e2,
    [ <op-to-ebc> op ]
  ]
  
  //-----------------------------------------------------------------------------------------------
  //Operators
  //-----------------------------------------------------------------------------------------------
  //Simple operators that will work without any other information
  op-to-ebc: Plus()   -> ADD()
  op-to-ebc: Minus()  -> SUB()
  op-to-ebc: Mult()   -> MUL()
  op-to-ebc: Pow()    -> EXP()
  op-to-ebc: BitAnd() -> AND()
  op-to-ebc: BitOr()  -> OR()
  op-to-ebc: BitXor() -> XOR()
  op-to-ebc: BitNot() -> NOT()
  
  //TODO
  
  //-----------------------------------------------------------------------------------------------
  //Nabl types
  //-----------------------------------------------------------------------------------------------
  return-type: FunctionT(_, [retT]) -> retT
  